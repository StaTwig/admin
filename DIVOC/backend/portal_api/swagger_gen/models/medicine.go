// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Medicine Medicine
//
// swagger:model Medicine
type Medicine struct {

	// Interval for Doses
	//
	// How many days to wait after each dose
	DoseIntervals []*MedicineDoseIntervalsItems0 `json:"doseIntervals"`

	// Effective until (Days)
	//
	// Effective until n days after the last dose
	// Minimum: 0
	EffectiveUntil *int64 `json:"effectiveUntil,omitempty"`

	// Name of Vaccine / Medicine
	// Required: true
	Name *string `json:"name"`

	// Price Range
	// Minimum: 0
	Price *float64 `json:"price,omitempty"`

	// Manufacturer
	// Required: true
	Provider *string `json:"provider"`

	// Status
	// Required: true
	// Enum: [Active Inactive Blocked]
	Status *string `json:"status"`

	// vaccination mode
	// Enum: [muscular injection oral nasal]
	VaccinationMode *string `json:"vaccinationMode,omitempty"`
}

// Validate validates this medicine
func (m *Medicine) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDoseIntervals(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEffectiveUntil(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProvider(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVaccinationMode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Medicine) validateDoseIntervals(formats strfmt.Registry) error {

	if swag.IsZero(m.DoseIntervals) { // not required
		return nil
	}

	for i := 0; i < len(m.DoseIntervals); i++ {
		if swag.IsZero(m.DoseIntervals[i]) { // not required
			continue
		}

		if m.DoseIntervals[i] != nil {
			if err := m.DoseIntervals[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("doseIntervals" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Medicine) validateEffectiveUntil(formats strfmt.Registry) error {

	if swag.IsZero(m.EffectiveUntil) { // not required
		return nil
	}

	if err := validate.MinimumInt("effectiveUntil", "body", int64(*m.EffectiveUntil), 0, false); err != nil {
		return err
	}

	return nil
}

func (m *Medicine) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *Medicine) validatePrice(formats strfmt.Registry) error {

	if swag.IsZero(m.Price) { // not required
		return nil
	}

	if err := validate.Minimum("price", "body", float64(*m.Price), 0, false); err != nil {
		return err
	}

	return nil
}

func (m *Medicine) validateProvider(formats strfmt.Registry) error {

	if err := validate.Required("provider", "body", m.Provider); err != nil {
		return err
	}

	return nil
}

var medicineTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Active","Inactive","Blocked"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		medicineTypeStatusPropEnum = append(medicineTypeStatusPropEnum, v)
	}
}

const (

	// MedicineStatusActive captures enum value "Active"
	MedicineStatusActive string = "Active"

	// MedicineStatusInactive captures enum value "Inactive"
	MedicineStatusInactive string = "Inactive"

	// MedicineStatusBlocked captures enum value "Blocked"
	MedicineStatusBlocked string = "Blocked"
)

// prop value enum
func (m *Medicine) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, medicineTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Medicine) validateStatus(formats strfmt.Registry) error {

	if err := validate.Required("status", "body", m.Status); err != nil {
		return err
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", *m.Status); err != nil {
		return err
	}

	return nil
}

var medicineTypeVaccinationModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["muscular injection","oral","nasal"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		medicineTypeVaccinationModePropEnum = append(medicineTypeVaccinationModePropEnum, v)
	}
}

const (

	// MedicineVaccinationModeMuscularInjection captures enum value "muscular injection"
	MedicineVaccinationModeMuscularInjection string = "muscular injection"

	// MedicineVaccinationModeOral captures enum value "oral"
	MedicineVaccinationModeOral string = "oral"

	// MedicineVaccinationModeNasal captures enum value "nasal"
	MedicineVaccinationModeNasal string = "nasal"
)

// prop value enum
func (m *Medicine) validateVaccinationModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, medicineTypeVaccinationModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Medicine) validateVaccinationMode(formats strfmt.Registry) error {

	if swag.IsZero(m.VaccinationMode) { // not required
		return nil
	}

	// value enum
	if err := m.validateVaccinationModeEnum("vaccinationMode", "body", *m.VaccinationMode); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Medicine) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Medicine) UnmarshalBinary(b []byte) error {
	var res Medicine
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// MedicineDoseIntervalsItems0 medicine dose intervals items0
//
// swagger:model MedicineDoseIntervalsItems0
type MedicineDoseIntervalsItems0 struct {

	// Maximum Interval
	// Minimum: 0
	Max *int64 `json:"max,omitempty"`

	// Minimum Interval
	// Required: true
	// Minimum: 0
	Min *int64 `json:"min"`
}

// Validate validates this medicine dose intervals items0
func (m *MedicineDoseIntervalsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMax(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMin(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MedicineDoseIntervalsItems0) validateMax(formats strfmt.Registry) error {

	if swag.IsZero(m.Max) { // not required
		return nil
	}

	if err := validate.MinimumInt("max", "body", int64(*m.Max), 0, false); err != nil {
		return err
	}

	return nil
}

func (m *MedicineDoseIntervalsItems0) validateMin(formats strfmt.Registry) error {

	if err := validate.Required("min", "body", m.Min); err != nil {
		return err
	}

	if err := validate.MinimumInt("min", "body", int64(*m.Min), 0, false); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MedicineDoseIntervalsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MedicineDoseIntervalsItems0) UnmarshalBinary(b []byte) error {
	var res MedicineDoseIntervalsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
